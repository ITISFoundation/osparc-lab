#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class SceneFileFormat(object):
    GLTF = 0
    GLB = 1

    _VALUES_TO_NAMES = {
        0: "GLTF",
        1: "GLB",
    }

    _NAMES_TO_VALUES = {
        "GLTF": 0,
        "GLB": 1,
    }


class BooleanOperationType(object):
    UNITE = 0
    INTERSECT = 1
    SUBTRACT = 2

    _VALUES_TO_NAMES = {
        0: "UNITE",
        1: "INTERSECT",
        2: "SUBTRACT",
    }

    _NAMES_TO_VALUES = {
        "UNITE": 0,
        "INTERSECT": 1,
        "SUBTRACT": 2,
    }


class EntityFilterType(object):
    ALL = 0
    MESH = 1
    BODY = 2
    BODY_AND_MESH = 3

    _VALUES_TO_NAMES = {
        0: "ALL",
        1: "MESH",
        2: "BODY",
        3: "BODY_AND_MESH",
    }

    _NAMES_TO_VALUES = {
        "ALL": 0,
        "MESH": 1,
        "BODY": 2,
        "BODY_AND_MESH": 3,
    }


class ApiVersion(object):
    """
    Attributes:
     - major
     - minor
    """


    def __init__(self, major=0, minor=1,):
        self.major = major
        self.minor = minor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.major = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.minor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ApiVersion')
        if self.major is not None:
            oprot.writeFieldBegin('major', TType.I32, 1)
            oprot.writeI32(self.major)
            oprot.writeFieldEnd()
        if self.minor is not None:
            oprot.writeFieldBegin('minor', TType.I32, 2)
            oprot.writeI32(self.minor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Entity(object):
    """
    Attributes:
     - name
     - uuid
     - children
     - has_geometry
    """


    def __init__(self, name=None, uuid=None, children=None, has_geometry=True,):
        self.name = name
        self.uuid = uuid
        self.children = children
        self.has_geometry = has_geometry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.children = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Entity()
                        _elem5.read(iprot)
                        self.children.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.has_geometry = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Entity')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.children is not None:
            oprot.writeFieldBegin('children', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.children))
            for iter6 in self.children:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.has_geometry is not None:
            oprot.writeFieldBegin('has_geometry', TType.BOOL, 4)
            oprot.writeBool(self.has_geometry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Color(object):
    """
    Attributes:
     - r
     - g
     - b
     - a
    """


    def __init__(self, r=None, g=None, b=None, a=1,):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.g = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.b = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Color')
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 1)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.g is not None:
            oprot.writeFieldBegin('g', TType.DOUBLE, 2)
            oprot.writeDouble(self.g)
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin('b', TType.DOUBLE, 3)
            oprot.writeDouble(self.b)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Material(object):
    """
    Attributes:
     - diffuse
    """


    def __init__(self, diffuse=None,):
        self.diffuse = diffuse

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.diffuse = Color()
                    self.diffuse.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Material')
        if self.diffuse is not None:
            oprot.writeFieldBegin('diffuse', TType.STRUCT, 1)
            self.diffuse.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Vertex(object):
    """
    Attributes:
     - x
     - y
     - z
    """


    def __init__(self, x=None, y=None, z=None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Vertex')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Vector(object):
    """
    Attributes:
     - x
     - y
     - z
    """


    def __init__(self, x=None, y=None, z=None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Vector')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntityMesh(object):
    """
    Attributes:
     - vertices
     - normals
     - triangles
     - transform4x4
     - material
     - lines
     - points
    """


    def __init__(self, vertices=None, normals=None, triangles=None, transform4x4=None, material=None, lines=None, points=None,):
        self.vertices = vertices
        self.normals = normals
        self.triangles = triangles
        self.transform4x4 = transform4x4
        self.material = material
        self.lines = lines
        self.points = points

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vertices = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readDouble()
                        self.vertices.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.normals = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readDouble()
                        self.normals.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.triangles = []
                    (_etype22, _size19) = iprot.readListBegin()
                    for _i23 in range(_size19):
                        _elem24 = iprot.readI32()
                        self.triangles.append(_elem24)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.transform4x4 = []
                    (_etype28, _size25) = iprot.readListBegin()
                    for _i29 in range(_size25):
                        _elem30 = iprot.readDouble()
                        self.transform4x4.append(_elem30)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.material = Material()
                    self.material.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.lines = []
                    (_etype34, _size31) = iprot.readListBegin()
                    for _i35 in range(_size31):
                        _elem36 = iprot.readI32()
                        self.lines.append(_elem36)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readI32()
                        self.points.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntityMesh')
        if self.vertices is not None:
            oprot.writeFieldBegin('vertices', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.vertices))
            for iter43 in self.vertices:
                oprot.writeDouble(iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.normals is not None:
            oprot.writeFieldBegin('normals', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.normals))
            for iter44 in self.normals:
                oprot.writeDouble(iter44)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.triangles is not None:
            oprot.writeFieldBegin('triangles', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.triangles))
            for iter45 in self.triangles:
                oprot.writeI32(iter45)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.transform4x4 is not None:
            oprot.writeFieldBegin('transform4x4', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.transform4x4))
            for iter46 in self.transform4x4:
                oprot.writeDouble(iter46)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.material is not None:
            oprot.writeFieldBegin('material', TType.STRUCT, 5)
            self.material.write(oprot)
            oprot.writeFieldEnd()
        if self.lines is not None:
            oprot.writeFieldBegin('lines', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.lines))
            for iter47 in self.lines:
                oprot.writeI32(iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.points))
            for iter48 in self.points:
                oprot.writeI32(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncodedScene(object):
    """
    Attributes:
     - fileType
     - data
    """


    def __init__(self, fileType=None, data=None,):
        self.fileType = fileType
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.fileType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncodedScene')
        if self.fileType is not None:
            oprot.writeFieldBegin('fileType', TType.I32, 1)
            oprot.writeI32(self.fileType)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntityLine(object):
    """
    Attributes:
     - vertices
     - transform4x4
     - material
    """


    def __init__(self, vertices=None, transform4x4=None, material=None,):
        self.vertices = vertices
        self.transform4x4 = transform4x4
        self.material = material

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vertices = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = Vertex()
                        _elem54.read(iprot)
                        self.vertices.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.transform4x4 = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readDouble()
                        self.transform4x4.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.material = Material()
                    self.material.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntityLine')
        if self.vertices is not None:
            oprot.writeFieldBegin('vertices', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.vertices))
            for iter61 in self.vertices:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.transform4x4 is not None:
            oprot.writeFieldBegin('transform4x4', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.transform4x4))
            for iter62 in self.transform4x4:
                oprot.writeDouble(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.material is not None:
            oprot.writeFieldBegin('material', TType.STRUCT, 3)
            self.material.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelerException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelerException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ApiVersion)
ApiVersion.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'major', None, 0, ),  # 1
    (2, TType.I32, 'minor', None, 1, ),  # 2
)
all_structs.append(Entity)
Entity.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'children', (TType.STRUCT, [Entity, None], False), None, ),  # 3
    (4, TType.BOOL, 'has_geometry', None, True, ),  # 4
)
all_structs.append(Color)
Color.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'r', None, None, ),  # 1
    (2, TType.DOUBLE, 'g', None, None, ),  # 2
    (3, TType.DOUBLE, 'b', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, 1, ),  # 4
)
all_structs.append(Material)
Material.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'diffuse', [Color, None], None, ),  # 1
)
all_structs.append(Vertex)
Vertex.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(Vector)
Vector.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(EntityMesh)
EntityMesh.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vertices', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'normals', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'triangles', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'transform4x4', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRUCT, 'material', [Material, None], None, ),  # 5
    (6, TType.LIST, 'lines', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'points', (TType.I32, None, False), None, ),  # 7
)
all_structs.append(EncodedScene)
EncodedScene.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'fileType', None, None, ),  # 1
    (2, TType.STRING, 'data', 'BINARY', None, ),  # 2
)
all_structs.append(EntityLine)
EntityLine.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vertices', (TType.STRUCT, [Vertex, None], False), None, ),  # 1
    (2, TType.LIST, 'transform4x4', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.STRUCT, 'material', [Material, None], None, ),  # 3
)
all_structs.append(ModelerException)
ModelerException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
